#!/usr/bin/env python

from argparse import ArgumentParser
import sys


def mymath(var1, var2, var3): #define a function called mymath that takes in inputs var1, var2, var3
    if var2: #var 2 is a flag argument that determines whether or not you print your output (see below). If it's defined, you print var1 + var2.
        return var1 + var3
    else:
        return "no print"


def main():
    parser = ArgumentParser("name", description="my desc") #start building your parser
    parser.add_argument("var1", action="store", help="the variable!")#first argument. Its name is var1, and it's a positional
    #argument. That means that it is defined by where it is. So the first number you provide will always be var1. It is a
    #mandatory argument. Given that it's a mandatory argument, you store it.
    parser.add_argument("var3", action="store", help="the variable!") #var3 is the second argument. Now you have 2 positional
    #arguments, the first of which will always be var1 and the second always var3.
    parser.add_argument("--var2", "-v", action="store_true", help="another!")#var2 is a flag. Its names are --var2 or -v. This
    #argument is a flag that tells your script to do something, so the only thing you care about is if it exists or not. That
    #is why its action is "store_true", which means, if it exists, its value is True.
    results = parser.parse_args() #parse_args is a function of an ArgumentParser. It essentially just stores the arguments in
    #'results'.

    def sanity_check(inpt, name):#define another function called sanity_check that takes two inputs: inpt and name (which are defined below)
        if name in ["var1", "var3"]:#if the 'name' input is either var1 or var3 (which it will be by definition because they are positional
        #arguments), do the following:
            try:#'try/except' is apparently a very common way to do error-handling. It essentially says that it tries to do
            #something if the condition in the 'if-statement' is satisfied, but if it isn't, at least try going through the
            #exception.
                inpt = int(inpt)#here's what we're trying: to transform 'inpt' into an interger (note: apparently argparser
                #tends to store things as strings, although maybe you can define its class as interger in add_argument)
                return inpt #here you make the variable available to the rest of your script. Greg suggested that here is
                #where I should use nibabel to get my images and check if they are nifti.
            except:
                print("faileeeeed, not an int")#essentially an error message.
                sys.exit(-1)#a function of the 'sys' library, exits the script.
        elif name == "var2":#if the 'name' input is var2, do the following:
            print('bool: nothing to do')#print this statement
            return inpt#Remember that var2 is an argument that defines whether you print the output or not. The inputs (var1,
            #var2, and var3) are defined below by calling this function ('sanity_check'). If you don't use the var2 flag, you
            #won't return inpt, which as you can see below, is the first argument of the sanity_check.

    var1 = sanity_check(results.var1, "var1")#the variable var1 is defined by the output of the 'sanity_check' function.
    #It is equal to 'inpt'. The arguments given to 'sanity_check' are 'results' (defined by the ArgumentParser.parse_args)
    #.NAMEOFARGUMENT (which we added above using 'add_argument').
    var2 = sanity_check(results.var2, "var2")
    var3 = sanity_check(results.var3, "var3")

    #The 'sanity_check' function isn't necessary for the main function of the script ('my_math'), but it's a way to verify that
    #the format of the input is correct.

    print(mymath(var1, var2, var3))#Here you call 'my_math' by feeding it var1,var2,var3, which were generated by calling the
    #'sanity_check' function.


if __name__ == "__main__": #__name__ is a built-in argument in python, and it means â€œthe main function of the script (I think).
#It seems like you will see it on every script.
    main()#I don't understand what you define as your main function. It seems like you build your argparser there.
